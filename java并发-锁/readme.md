##乐观锁VS悲观锁
线程是不是要锁住同步资源？

锁——悲观锁

不锁——乐观锁

悲观锁：synchronized关键字、Lock的实现类

乐观锁：无锁编程实现，CAS算法。

乐观锁认为之间在使用数据时不会有别的线程来修改数据，所以不添加锁。
更新数据时判断之前有没有其他线程修改了这个数据。如果没有被更新，当前
线程的数据写入成功。如果数据已经被其他线程更新，则根据不同的实现方式
采取不同的操作（报错或者自动重试）

悲观锁适合用于写操作多的场景，先加锁保证写操作时数据正确

乐观锁适合用于读操作多的场景，不加锁的特点是使读操作的性能大幅提高



###为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？


##自旋锁VS适应性自旋锁
锁住同步资源失败，线程要不要阻塞？

不阻塞——自旋锁/适应性自旋锁

###为什么需要自旋锁？
阻塞或唤醒一个Java线程需要操作系统切换cpu状态来完成，这种状态切换是需要耗费
处理器时间的。如果同步代码快的内容过于简单，切换状态耗费的时间比代码执行的时间
还要长。

在许多场景下，同步资源的锁定时间非常短，为了这一小段时间去切换线程，线程挂起和
恢复现场的花费让系统会得不偿失。如果物理机器有多个处理器能够让两个或两个以上的
线程并行执行，我们可以让后面那个请求锁的线程不放弃cpu的执行时间，看持有锁的线程
是否很快释放锁。

而为了让线程稍等一下，我们让当前线程进行自旋，如果自旋完成后前面锁定同步资源的
线程已经释放了锁。那么当前线程就可以不阻塞直接获得同步资源，从而避免切换线程
带来的开销。


通过自旋操作减少cpu切换已经恢复现场带来的消耗

缺点：

自旋锁不等代替阻塞，虽然避免了线程切换带来的开销，当时占用处理器时间。
自旋等待的时间必须有限制，如果超过限制次数没有获得锁，将当前线程挂起。

自旋的实现远离CAS

补充看：关键字 - synchronized详解 - 自旋锁与自适应自旋锁



##无锁VS偏向性锁VS轻量级锁VS重量级锁
多个线程竞争同步资源的流程细节有没有区别？

不锁住资源，多个线程只有一个能修改资源成功，其他线程会重试——无锁

同一个线程执行同步资源时自动获取资源——偏向锁

多个线程竞争同步资源时，没有获得资源的线程自旋等待锁释放——轻量级锁

多个线程竞争同步资源时，没有获得资源的线程阻塞等待唤醒——重量级锁

四种状态针对synchronized

总结：

偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作；
轻量级锁通过CAS操作和自旋解决加锁问题，避免线程阻塞和唤醒影响性能
重量级锁是将拥有锁以外的所有线程阻塞。

补充看：关键字 - synchronized详解 - 锁的类型
    


##公平锁VS非公平锁
多个线程竞争锁时是否排队？

排队——公平锁

先尝试插队，插队失败时排队——非公平锁

公平锁：

线程不会饿死，但相比非公平锁吞吐率低，唤醒阻塞线程开销大

非公平锁：

减少唤醒阻塞线程开销，吞吐率高。但线程可能会饿死或长时间等待

更多补充：JUC - ReentrantLock详解

##可重入锁VS非可重入锁
一个线程的多个流程能不能获得同一把锁？

能——可重入锁

不能——非可重入锁

可重入锁，又叫递归锁。同一线程的外层方法获得锁时，再次进入该线程的内层方法时
会自动获取锁（锁对象必须是同一个对象或class），不会因为之前获得锁没释放而阻塞。
ReentrantLock和synchronized都是可重入锁。一定成都市上避免了锁死

源码分析

继承AbstractQueuedSynchronizer实现 维护同步状态status来计数重入次数

补充：

JUC锁: LockSupport详解
   
JUC锁: AbstractQueuedSynchronizer详解
   
JUC锁 - ReentrantLock详解。
   
关键字 - synchronized详解

##独享锁（排他锁）VS共享锁
多个线程能不能共享一把锁？

能——共享锁

不能——排他锁

排他锁：一个线程对数据加上排他锁后，可读写，其他线程不能对该数据进行加锁。
JDK中的synchronized关键字和JUC中的Lock的实现类是排他锁

共享锁：可被多个线程持有。如果一个线程对数据加上共享锁后，其他线程只能加
上共享锁。获得共享锁的线程只能读数据

排他锁和共享锁通过继承AQS实现

补充看：JUC锁: ReentrantReadWriteLock详解


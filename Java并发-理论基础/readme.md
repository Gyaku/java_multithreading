##多线程的出现是要解决什么问题的

平衡cpu、内存、I/O设备之间的速度差异，合理利用cpu的高性能

1.cpu增加了缓存，解决cpu和内存间的速度差异

2.操作系统增加了进程和线程，以分时复用cpu，平衡cpu和I/O设备间的速度差异

3.编译器优化指令的执行顺序 使缓存合理利用 

##线程不安全是指什么? 

多线程访问同一共享数据，不采用同步操作，结果会不一致

##举例说明并发出现线程不安全的本质什么? 可见性，原子性和有序性。

###可见性 cpu缓存引起

一个线程对共享数据进行了修改，另一个线程应该立刻看到


###原子性 分时复用引起

一个或多个操作是一个整体，要么全部执行完成且不能打断，要么不执行， 

###有序性 指令重排序引起

程序执行顺序按照代码的先后顺序执行 

程序执行时为了提高性能，编译器和处理器都会进行指令重排


##Java是怎么解决并发问题的? 3个关键字，JMM和8个Happens-Before

###理解的第一个维度：核心知识点

JMM Java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法，方法包括：

volatile， synchronized, final 三个关键字

8个Happens-Before

###理解的第二个维度：可见性，有序性，原子性

####原子性问题

Java中对基本数据类型的赋值和读取操作是原子性的、不可打断的

JMM只保证了基本数据类型是原子性的，更大范围通过synchronized和Lock来实现

_synchronized_、_lock_ ：任一时刻只有一个线程执行该代码块  


####可见性问题

_volatile_：修饰变量（共享变量），变量被修改会马上更新到主存，
          其他线程读取，去内存中取新值
          
_synchronized_、_lock_

####有序性问题

_volatile_、_synchronized_、_lock_

_Happens-Before_ 并发先行原则

1.单一线程原则

2.管程锁定原则：一个unlock优先于下一个同一个锁的lock。
Java中管程由synchronized实现。锁是隐式实现：代码执行加锁，结束解锁，编译器自动
  
3.volatile变量原则：对变量的写优先于对后面对变量的读

4.线程启动原则：Thread对象的start()方法先行

5.线程加入原则：Thread对象的结束优先于join()方法的返回

6.线程中断原则；interrupt()

7.对象终结原则：finalize()

8.传递性原则：      

##线程安全是不是非真即假? 

不是 按照共享数据安全强度的强弱分为五类

####1.不可变

线程安全，

不可变的类型有final、String、枚举、Number类的基本类型包装类以及大数据类。
对于集合，采用Collections.unmodifiableXXX()

####2.绝对线程安全

####3.相对线程安全

保证对象单独操作是安全的。
Java大部分都是。Vector、HashTable、Collections.synchronizedCollection()

####4.线程兼容

对象不安全
Java大部分。ArrayList、HashMap

####5.线程对立


##线程安全有哪些实现思路?

###1.互斥同步（阻塞同步）

synchronized、ReentrantLock

悲观的并发策略

主要问题：线程阻塞和唤醒的性能问题

###2.非阻塞同步

####1.CAS （冲突检测 compare-and-swap）

乐观并发

乐观锁有两个步骤：操作、冲突检测（如果没有其他线程竞争就成功，否则采取补偿措施（重试））。这两个操作是原子性的。
由硬件来完成 三个值 V（内存地址） A（预估的旧值） B（新值）

V == A ？V = B ：重试

####2.AtomicInteger

JUC包中的整数原子类

使用的是Unsafe类的CAS操作

####3.ABA

如果一个变量初始值是A，后来变成了B，最后又变成了A，CAS认为没有变过

JUC包的AtomicStampedReference 可解决

但是大部分情况不影响并发正确，解决ABA问题，考虑到性能不如使用互斥同步

###3.无同步

不一定需要同步，不涉及共享数据

####1.栈封闭

多线程访问同一方法中的局部变量时，不会有线程安全问题。因为局部变量存储在JVM中，是线程私有的

####2.线程本地存储

保证共享数据在同一线程中执行，便无需同步。

#####1.消费队列的架构模式"生产者-消费者"。消费在一个线程中完成

#####2.web经典交互模式"一个请求一个服务器线程"，web服务器使用的线程在服务器本地存储

#####3.ThreadLocal

Thread中有成员ThreadLocal.ThreadLocalMap，不存在多线程竞争

用后调用remove()方法，避免内存泄漏

####3.可重入代码。纯代码

##如何理解并发和并行的区别?

并发是指一个处理器同时处理多个任务。

并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。
